<script>
  const els = {
    q: document.getElementById('q'),
    country: document.getElementById('country'),
    start: document.getElementById('start'),
    end: document.getElementById('end'),
    clear: document.getElementById('clear'),
    status: document.getElementById('status'),
    summary: document.getElementById('summary'),
    tbody: document.getElementById('tbody'),
    thead: document.getElementById('thead'),
    prev: document.getElementById('prev'),
    next: document.getElementById('next'),
    chartA: document.getElementById('chartTopArtists'),
    chartC: document.getElementById('chartTopCountries')
  };

  const PAGE_SIZE = 100;
  let sortBy = 'date';
  let sortDir = 'desc';
  let offset = 0;
  let total = 0;

  let charts = {};

  const uniqSorted = a => Array.from(new Set(a.filter(Boolean))).sort((x,y)=>x.localeCompare(y));
  const selected = sel => Array.from(sel.selectedOptions).map(o=>o.value);
  const fmtDate = iso => {
    const d = new Date(iso); if(isNaN(d)) return '';
    const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), da=String(d.getDate()).padStart(2,'0');
    return `${y}-${m}-${da}`;
  };
  const comma = n => Number(n).toLocaleString();
  function statusLine(offset, limit, total){
    const start = total ? offset + 1 : 0;
    const end   = Math.min(offset + limit, total);
    const page  = total ? Math.floor(offset/limit)+1 : 0;
    const pages = total ? Math.ceil(total/limit) : 0;
    return `${comma(start)} - ${comma(end)} of ${comma(total)} (Page ${comma(page)} / ${comma(pages)})`;
  }

  async function fetchJSON(url){
    const res = await fetch(url);
    if (!res.ok) throw new Error(`${res.status} ${res.statusText} @ ${url}`);
    return res.json();
  }

  // -------- initial options (countries + date range) --------
  async function loadFilterOptions(){
    const url = new URL('/api/releases', location.origin);
    url.searchParams.set('limit', '1000');
    url.searchParams.set('sortBy', 'date');
    url.searchParams.set('sortDir', 'asc');
    const { results=[] } = await fetchJSON(url);
    const countries = uniqSorted(results.map(r=>r.country));
    els.country.innerHTML='';
    for(const c of countries){ const o=document.createElement('option'); o.value=c; o.textContent=c; els.country.appendChild(o); }
    if (results.length){
      const ys = results.map(r=>new Date(r.date).getFullYear());
      const minY = Math.min(...ys), maxY = Math.max(...ys);
      els.start.value = `${minY}-01-01`;
      els.end.value   = `${maxY}-12-31`;
    }
  }

  function buildQuery(base){
    const u = new URL(base, location.origin);
    const qv = els.q.value.trim();
    const cn = selected(els.country);
    if (qv) u.searchParams.set('q', qv);
    cn.forEach(c=>u.searchParams.append('country', c));
    if (els.start.value) u.searchParams.set('start', els.start.value);
    if (els.end.value)   u.searchParams.set('end',   els.end.value);
    return u;
  }

  async function loadPage(){
    els.status.textContent = 'Loading…';
    // data for the table (paginated)
    const qTable = buildQuery('/api/releases');
    qTable.searchParams.set('limit', PAGE_SIZE.toString());
    qTable.searchParams.set('offset', offset.toString());
    qTable.searchParams.set('sortBy', sortBy);
    qTable.searchParams.set('sortDir', sortDir);
    const data = await fetchJSON(qTable.toString());

    total = data.total || 0;
    renderTable(data.results || []);
    renderStatus(); // uses global total + current offset
    setPagerButtons();
    setHeaderIcons();

    // data for the charts (global aggregates for current filters, NOT page)
    await loadCharts();

    els.status.textContent = '';
  }

  function renderStatus(){
    els.summary.textContent = statusLine(offset, PAGE_SIZE, total);
  }
  function setPagerButtons(){
    els.prev.disabled = (offset === 0);
    els.next.disabled = (offset + PAGE_SIZE >= total);
  }
  function setHeaderIcons(){
    document.querySelectorAll('th[data-key] .dir').forEach(el=>el.textContent='');
    const th = document.querySelector(`th[data-key="${sortBy}"] .dir`);
    if (th) th.textContent = sortDir === 'asc' ? '▲' : '▼';
  }

  function renderTable(rows){
    els.tbody.innerHTML = '';
    for (const r of rows){
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${r.artist || ''}</td>
        <td>${r.release || ''}</td>
        <td>${r.country || ''}</td>
        <td>${fmtDate(r.date)}</td>
      `;
      els.tbody.appendChild(tr);
    }
  }

  function makeOrUpdateChart(key, ctx, config){
    if (charts[key]) charts[key].destroy();
    charts[key] = new Chart(ctx, config);
  }

  async function loadCharts(){
    // call the global stats endpoint with the SAME filters (no offset/limit)
    const qStats = buildQuery('/api/release-stats');
    const { topArtists=[], topCountries=[] } = await fetchJSON(qStats.toString());

    // Top 5 Artist - by Release Count
    makeOrUpdateChart(
      'A',
      els.chartA.getContext('2d'),
      {
        type:'bar',
        data:{
          labels: topArtists.map(x=>x.label),
          datasets:[{ label:'Releases', data: topArtists.map(x=>x.count) }]
        },
        options:{
          plugins:{ title:{ display:true, text:'Top 5 Artist - by Release Count' }},
          scales:{ y:{ beginAtZero:true, ticks:{ precision:0 }}}
        }
      }
    );

    // Top 5 Countries - by Release Count
    makeOrUpdateChart(
      'C',
      els.chartC.getContext('2d'),
      {
        type:'bar',
        data:{
          labels: topCountries.map(x=>x.label),
          datasets:[{ label:'Total Releases', data: topCountries.map(x=>x.count) }]
        },
        options:{
          plugins:{ title:{ display:true, text:'Top 5 Countries - by Release Count' }},
          scales:{ y:{ beginAtZero:true, ticks:{ precision:0 }}}
        }
      }
    );
  }

  // ---------- events ----------
  const debounce = (fn, ms=200) => { let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; };

  // sort on header click
  els.thead.addEventListener('click', (e)=>{
    const th = e.target.closest('th[data-key]');
    if (!th) return;
    const key = th.getAttribute('data-key');
    if (sortBy === key){ sortDir = (sortDir === 'asc' ? 'desc' : 'asc'); }
    else { sortBy = key; sortDir = (key === 'date' ? 'desc' : 'asc'); }
    offset = 0;
    loadPage().catch(console.error);
  });

  // filters (reset to first page + reload page + reload global charts)
  const onFilter = debounce(()=>{ offset = 0; loadPage().catch(console.error); }, 250);
  els.q.addEventListener('input', onFilter);
  els.country.addEventListener('change', onFilter);
  els.start.addEventListener('change', onFilter);
  els.end.addEventListener('change', onFilter);

  // clear filters
  els.clear.addEventListener('click', async ()=>{
    els.q.value = '';
    Array.from(els.country.options).forEach(o=>o.selected=false);
    await loadFilterOptions(); // resets dates to full range
    sortBy = 'date'; sortDir = 'desc'; offset = 0;
    loadPage().catch(console.error);
  });

  // pagination
  els.prev.addEventListener('click', ()=>{ offset = Math.max(0, offset - PAGE_SIZE); loadPage().catch(console.error); });
  els.next.addEventListener('click', ()=>{ offset = Math.min(Math.max(0, total - PAGE_SIZE), offset + PAGE_SIZE); loadPage().catch(console.error); });

  // ---------- boot ----------
  (async ()=>{
    try {
      await loadFilterOptions();
      await loadPage();
    } catch (e) {
      els.status.innerHTML = `<span class="error">${String(e.message || e)}</span>`;
    }
  })();
</script>
